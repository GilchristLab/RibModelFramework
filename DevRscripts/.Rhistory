nIter=iterations, p.Init=p.init, iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
rm("my.drawBPrior")
results <- cubmultichain(cubmethods, nsamples=config$use.n.samples, reset.qr=config$reset.qr, seeds=seeds, teston="sphi",
swap=config$swap, swapAt=config$swapAt, min=config$min.samples, max=config$max.samples,
nchains=config$n.chains, conv.thin=config$conv.thin, eps=config$eps, growthfactor=config$gf,
#monitor=function(x, i){cat(paste("I am monitor for chain", i, "\n"))},
ncores=config$n.cores, reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi,
nIter=iterations, p.Init=p.init, iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
load("~/CodonUsageBias/R_roc/debug.RData")
results <- cubsinglechain(cubmethods, frac1=config$frac1, frac2=config$frac2,
reset.qr=config$reset.qr, seed=seeds[1], teston="sphi",
min=config$min.samples, max=config$max.samples, conv.thin=config$conv.thin, eps=config$eps,
reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi[[1]],
nIter=iterations, p.Init=p.init[[1]], iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
suppressMessages(library(cubfits, quietly = TRUE))
.cubfitsEnv$
.cubfitsEnv
.cubfitsEnv
cubfits:::my.fitMultinomOne.roc
results <- cubsinglechain(cubmethods, frac1=config$frac1, frac2=config$frac2,
reset.qr=config$reset.qr, seed=seeds[1], teston="sphi",
min=config$min.samples, max=config$max.samples, conv.thin=config$conv.thin, eps=config$eps,
reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi[[1]],
nIter=iterations, p.Init=p.init[[1]], iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
chain <- results$chains
plotTraces(chain$b.Mat, config$aa, param="logmu", main=paste("AA parameter trace ", prefix, sep=""))
prefix <- "test"
plotTraces(chain$b.Mat, config$aa, param="logmu", main=paste("AA parameter trace ", prefix, sep=""))
plotTraces(chain$b.Mat, config$aa, param="deltaeta", main=paste("AA parameter trace ", prefix, sep=""))
logL <- chain$logL.Mat[[length(chain$logL.Mat)]]
plot(unlist(chain$logL.Mat), type="l", main=paste("logL:", logL), xlab="Iteration", ylab="logL")
yaa <- data$y[[1]]
naa <- data$n[[1]]
qr.arg = FALSE
y.arg = FALSE
x.arg = FALSE
coefstart = NULL
tmp.phi <- init.phi
phi <- init.phi
names.phi <- names(phi)
tmp.id <- names.phi %in% names(naa)[naa > 0]
ret <- VGAM::vglm(yaa[tmp.id,] ~ tmp.phi[tmp.id],
VGAM::multinomial, coefstart = coefstart,
x.arg = x.arg, y.arg = y.arg, qr.arg = qr.arg)
ret <- VGAM::vglm(yaa[tmp.id,] ~ tmp.phi[tmp.id],
VGAM::multinomial, coefstart = coefstart,
x.arg = x.arg, y.arg = y.arg, qr.arg = qr.arg)
phi <- init.phi[[1]]
tmp.phi <- init.phi[[1]]
ret <- VGAM::vglm(yaa[tmp.id,] ~ tmp.phi[tmp.id],
VGAM::multinomial, coefstart = coefstart,
x.arg = x.arg, y.arg = y.arg, qr.arg = qr.arg)
yaa[tmp.id,]
tmp.phi[tmp.id]
names.phi <- names(phi)
tmp.id <- names.phi %in% names(naa)[naa > 0]
### Obtain new beta (M, S_1) from vglm.
ret <- VGAM::vglm(yaa[tmp.id,] ~ tmp.phi[tmp.id],
VGAM::multinomial, coefstart = coefstart,
x.arg = x.arg, y.arg = y.arg, qr.arg = qr.arg)
ret@coefficients
coefficients <- ret@coefficients
## convert delta.t to delta.eta
#coefficients[(length(ret@coefficients)/2+1):length(coefficients)] <- -1 * coefficients[(length(ret@coefficients)/2+1):length(coefficients)]
coefficients <- -1 * coefficients
ret <- list(coefficients = coefficients,
coef.mat = matrix(ret@coefficients, nrow = 2, byrow = TRUE),
R = ret@R)
mu.prev <- ret$coefficients
mu <- ret$coefficients
R <- ret$R
zProp <- rnorm(length(mu))
prop <- mu + backsolve(R / b.DrawScale.aa, zProp)
prop <- mu + backsolve(R, zProp)
prop
zPrev <- (R) %*% (mu.prev - prop)
zPrev
-1/2 * (sum(zProp * zProp) - sum(zPrev * zPrev))
lir <- -1/2 * (sum(zProp * zProp) - sum(zPrev * zPrev))
mu <- -1 * ret$coefficients
mu.prev <- -1 * ret$coefficients
zProp <- rnorm(length(mu))
prop
prop <- mu + backsolve(R, zProp)
prop
zPrev <- (R) %*% (mu.prev - prop)
-1/2 * (sum(zProp * zProp) - sum(zPrev * zPrev))
lir
lir <- -1/2 * (sum(zProp * zProp) - sum(zPrev * zPrev))
mu.prev <- ret$coefficients
mu <- ret$coefficients
prop
prop <- mu + backsolve(R / b.DrawScale.aa, zProp)
prop <- mu + backsolve(R, zProp)
prop
mu + backsolve(R, zProp)
suppressMessages(library(cubfits, quietly = TRUE))
load("~/CodonUsageBias/R_roc/debug.RData")
results <- cubsinglechain(cubmethods, frac1=config$frac1, frac2=config$frac2,
reset.qr=config$reset.qr, seed=seeds[1], teston="sphi",
min=config$min.samples, max=config$max.samples, conv.thin=config$conv.thin, eps=config$eps,
reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi[[1]],
nIter=iterations, p.Init=p.init[[1]], iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
chain <- results$chains
plotTraces(chain$b.Mat, config$aa, param="logmu", main=paste("AA parameter trace ", prefix, sep=""))
prefix <- "debug"
plotTraces(chain$b.Mat, config$aa, param="logmu", main=paste("AA parameter trace ", prefix, sep=""))
plotTraces(chain$b.Mat, config$aa, param="deltaeta", main=paste("AA parameter trace ", prefix, sep=""))
logL <- chain$logL.Mat[[length(chain$logL.Mat)]]
plot(unlist(chain$logL.Mat), type="l", main=paste("logL:", logL), xlab="Iteration", ylab="logL")
load("~/CodonUsageBias/R_roc/debug.RData")
suppressMessages(library(cubfits, quietly = TRUE))
results <- cubsinglechain(cubmethods, frac1=config$frac1, frac2=config$frac2,
reset.qr=config$reset.qr, seed=seeds[1], teston="sphi",
min=config$min.samples, max=config$max.samples, conv.thin=config$conv.thin, eps=config$eps,
reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi[[1]],
nIter=iterations, p.Init=p.init[[1]], iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
chain <- results$chains
prefix <- "debug"
plotTraces(chain$b.Mat, config$aa, param="logmu", main=paste("AA parameter trace ", prefix, sep=""))
plotTraces(chain$b.Mat, config$aa, param="deltaeta", main=paste("AA parameter trace ", prefix, sep=""))
logL <- chain$logL.Mat[[length(chain$logL.Mat)]]
plot(unlist(chain$logL.Mat), type="l", main=paste("logL:", logL), xlab="Iteration", ylab="logL")
suppressMessages(library(cubfits, quietly = TRUE))
load("~/CodonUsageBias/R_roc/debug.RData")
results <- cubsinglechain(cubmethods, frac1=config$frac1, frac2=config$frac2,
reset.qr=config$reset.qr, seed=seeds[1], teston="sphi",
min=config$min.samples, max=config$max.samples, conv.thin=config$conv.thin, eps=config$eps,
reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi[[1]],
nIter=iterations, p.Init=p.init[[1]], iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
chain <- results$chains
plotTraces(chain$b.Mat, config$aa, param="logmu", main=paste("AA parameter trace ", prefix, sep=""))
prefix <- "test"
plotTraces(chain$b.Mat, config$aa, param="logmu", main=paste("AA parameter trace ", prefix, sep=""))
plotTraces(chain$b.Mat, config$aa, param="deltaeta", main=paste("AA parameter trace ", prefix, sep=""))
logL <- chain$logL.Mat[[length(chain$logL.Mat)]]
plot(unlist(chain$logL.Mat), type="l", main=paste("logL:", logL), xlab="Iteration", ylab="logL")
dev.off()
plotPTraces(chain$p.Mat)
test<- cbind(chain$phi.pred.Mat[[1001]])
hist(test, nclass=50)
hist(log(test), nclass=50)
suppressMessages(library(cubfits, quietly = TRUE))
load("~/CodonUsageBias/R_roc/debug.RData")
results <- cubsinglechain(cubmethods, frac1=config$frac1, frac2=config$frac2,
reset.qr=config$reset.qr, seed=seeds[1], teston="sphi",
min=config$min.samples, max=config$max.samples, conv.thin=config$conv.thin, eps=config$eps,
reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi[[1]],
nIter=iterations, p.Init=p.init[[1]], iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
names(results$chains$b.Mat[[1]]_
names(results$chains$b.Mat[[1]])
bmat.names <- names(results$chains$b.Mat[[1]])
bmat.names <- names(results$chains[[1]]$b.Mat[[1]])
load("~/CodonUsageBias/R_roc/debug.RData")
results <- cubsinglechain(cubmethods, frac1=config$frac1, frac2=config$frac2,
reset.qr=config$reset.qr, seed=seeds[1], teston="sphi",
min=config$min.samples, max=config$max.samples, conv.thin=config$conv.thin, eps=config$eps,
reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi[[1]],
nIter=iterations, p.Init=p.init[[1]], iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
suppressMessages(library(cubfits, quietly = TRUE))
results <- cubsinglechain(cubmethods, frac1=config$frac1, frac2=config$frac2,
reset.qr=config$reset.qr, seed=seeds[1], teston="sphi",
min=config$min.samples, max=config$max.samples, conv.thin=config$conv.thin, eps=config$eps,
reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi[[1]],
nIter=iterations, p.Init=p.init[[1]], iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
results <- cubsinglechain(cubmethods, frac1=config$frac1, frac2=config$frac2,
reset.qr=config$reset.qr, seed=seeds[1], teston="sphi",
min=config$min.samples, max=config$max.samples, conv.thin=config$conv.thin, eps=config$eps,
reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi[[1]],
nIter=iterations, p.Init=p.init[[1]], iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
source('~/CodonUsageBias/R_roc/config.r', echo=TRUE)
results <- list()
length(results) <- config$n.chains
results <- cubsinglechain(cubmethods, frac1=config$frac1, frac2=config$frac2,
reset.qr=config$reset.qr, seed=seeds[1], teston="sphi",
min=config$min.samples, max=config$max.samples, conv.thin=config$conv.thin, eps=config$eps,
reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi[[1]],
nIter=iterations, p.Init=p.init[[1]], iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
plotPTraces(results$chains$p.Mat)
dgamma(0.5, 5, 4) - dgamma(0, 5, 4)
dgamma(0, 5, 4) - dgamma(0.5, 5, 4)
dgamma(0.5, 5, 4)/dgamma(0, 5, 4)
dgamma(0, 5, 4)
dgamma(0.5, 5, 4)/dgamma(0.1, 5, 4)
suppressMessages(library(cubfits, quietly = TRUE))
load("~/CodonUsageBias/R_roc/debug.RData")
source('~/CodonUsageBias/R_roc/config.r', echo=TRUE)
results <- cubsinglechain(cubmethods, frac1=config$frac1, frac2=config$frac2,
reset.qr=config$reset.qr, seed=seeds[1], teston="sphi",
min=config$min.samples, max=config$max.samples, conv.thin=config$conv.thin, eps=config$eps,
reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi[[1]],
nIter=iterations, p.Init=p.init[[1]], iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
results <- cubsinglechain(cubmethods, frac1=config$frac1, frac2=config$frac2,
reset.qr=config$reset.qr, seed=seeds[1], teston="sphi",
min=config$min.samples, max=config$max.samples, conv.thin=config$conv.thin, eps=config$eps,
reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi[[1]],
nIter=iterations, p.Init=p.init[[1]], iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
load("~/CodonUsageBias/R_roc/debug.RData")
suppressMessages(library(cubfits, quietly = TRUE))
results <- cubsinglechain(cubmethods, frac1=config$frac1, frac2=config$frac2,
reset.qr=config$reset.qr, seed=seeds[1], teston="sphi",
min=config$min.samples, max=config$max.samples, conv.thin=config$conv.thin, eps=config$eps,
reu13.df.obs=data$reu13.df, y=data$y, n=data$n, phi.pred.Init=init.phi[[1]],
nIter=iterations, p.Init=p.init[[1]], iterThin=config$chain.thin,
model="roc", adaptive="simple", .CF.CT=.CF.CT, .CF.CONF=.CF.CONF)
plotPTraces(results$chains$p.Mat)
source('~/CodonUsageBias/localNSE/NSEexchange/R/load.genome.R', echo=TRUE)
d <- 10000*runif(1000)
P <- (1+(1000/d))^-8
plot(d,P, type="l", xlab="Distance(km)", ylab="P(Alien)")
d <- sort(10000*runif(1000))
P <- (1+(1000/d))^-8
plot(d,P, type="l", xlab="Distance(km)", ylab="P(Alien)")
d <- sort(100000*runif(1000))
P <- (1+(1000/d))^-8
plot(d,P, type="l", xlab="Distance(km)", ylab="P(Alien)")
plot(d,P, type="l", xlab="Distance(km)", ylab="P(Alien)", main="Probability that a species is considered Alien")
d <- sort(50000*runif(1000))
P <- (1+(1000/d))^-8
plot(d,P, type="l", xlab="Distance(km)", ylab="P(Alien)", main="Probability that a species is considered Alien")
plot(d,P, type="l", xlab="Distance(km)", ylab="P(Alien)", main="Probability that a species is considered Alien", lwd=2)
plot(d,P, type="l", xlab="Distance(km)", ylab="P(Alien)", main="Probability that a species is considered Alien", lwd=3)
B <- sort(50000*runif(1000))
P <- (1-exp(-0.002*B))*exp(-0.02*10)
plot(B,P, type="l", xlab="Ballast(l)", ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
B <- sort(50000*runif(1000))
P <- (1-exp(-0.002*B))*exp(-0.02*30)
plot(B,P, type="l", xlab="Ballast(l)", ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
B <- sort(5000*runif(1000))
P <- (1-exp(-0.002*B))*exp(-0.02*30)
plot(B,P, type="l", xlab="Ballast(l)", ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
B <- sort(5000*runif(1000))
P <- (1-exp(-0.002*B))*exp(-0.02*1)
plot(B,P, type="l", xlab="Ballast(l)", ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
B <- sort(5000*runif(1000))
P <- (1-exp(-0.002*B))*exp(-0.02*15)
plot(B,P, type="l", xlab="Ballast(l)", ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
B <- sort(5000*runif(1000))
P <- (1-exp(-0.002*B))*exp(-0.02*14)
plot(B,P, type="l", xlab="Ballast(l)", ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
B <- sort(5000*runif(1000))
P <- (1-exp(-0.002*B))*exp(-0.02*10)
plot(B,P, type="l", xlab="Ballast(l)", ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
B <- sort(3000*runif(1000))
P <- (1-exp(-0.002*B))*exp(-0.02*10)
plot(B,P, type="l", xlab="Ballast(l)", ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
plot(B*1000,P, type="l", xlab="Ballast(l)", ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
plot(B,P, type="l", xlab="Ballast(m^3)", ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
plot(B,P, type="l", xlab=expression("Ballast(m"^3")"), ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
plot(B,P, type="l", xlab=expression("Ballast(m"3")"), ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
expression("Ballast(m"3")")
expression("Ballast(m"[3]")")
expression("Ballast(m"~3~")")
plot(B,P, type="l", xlab=expression("Ballast(m"~3~")"), ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
plot(B,P, type="l", xlab=expression("Ballast("~m^{3}~")"), ylab="P(Intro)", main="Probability that an Alien is introduced", lwd=3)
sd(Tij)
Tij <- sort(10*runif(1000))
sd(Tij)
Sij <- sort(40*runif(1000))
sd(Sij)
Tij <- sort(40*runif(1000))
Sij <- sort(10*runif(1000))
P <- 0.00015*exp( -0.5*( (Tij/10)^2 + (Sij/3) ) )
contour(x = Tij, y = Sij, z = P)
P <- matrix(0, nrow = 1000, ncol = 1000)
for(i in 1:1000)
{
for(j in 1:1000)
{
P[i,j] <- 0.00015*exp( -0.5*( (Tij[i]/10)^2 + (Sij[j]/3) ) )
}
}
contour(x = Tij, y = Sij, z = P)
filled.contour(x = Tij, y = Sij, z = P)
Tij <- sort(10*runif(1000))
Sij <- sort(10*runif(1000))
P <- matrix(0, nrow = 1000, ncol = 1000)
for(i in 1:1000)
{
for(j in 1:1000)
{
P[i,j] <- 0.00015*exp( -0.5*( (Tij[i]/2)^2 + (Sij[j]/10) ) )
}
}
filled.contour(x = Tij, y = Sij, z = P)
Tij <- sort(10*runif(1000))
Sij <- sort(100*runif(1000))
P <- matrix(0, nrow = 1000, ncol = 1000)
for(i in 1:1000)
{
for(j in 1:1000)
{
P[i,j] <- 0.00015*exp( -0.5*( (Tij[i]/2)^2 + (Sij[j]/10) ) )
}
}
filled.contour(x = Tij, y = Sij, z = P)
filled.contour(x = Tij, y = Sij, z = P, xlab=expression(DeltaT[ij]))
filled.contour(x = Tij, y = Sij, z = P, xlab=expression(Delta~T[ij]))
Tij <- sort(10*runif(1000))
Sij <- sort(10*runif(1000))
P <- matrix(0, nrow = 1000, ncol = 1000)
for(i in 1:1000)
{
for(j in 1:1000)
{
P[i,j] <- 0.00015*exp( -0.5*( (Tij[i]/2)^2 + (Sij[j]/10) ) )
}
}
filled.contour(x = Tij, y = Sij, z = P, xlab=expression(Delta~T[ij]), ylab=expression(Delta~S[ij]))
Tij <- sort(10*runif(1000))
Sij <- sort(10*runif(1000))
P <- matrix(0, nrow = 1000, ncol = 1000)
for(i in 1:1000)
{
for(j in 1:1000)
{
P[i,j] <- 0.00015*exp( -0.5*( (Tij[i]/2)^2 + (Sij[j]/10)^2 ) )
}
}
filled.contour(x = Tij, y = Sij, z = P, xlab=expression(Delta~T[ij]), ylab=expression(Delta~S[ij]))
Tij <- sort(3*runif(1000))
Sij <- sort(10*runif(1000))
P <- matrix(0, nrow = 1000, ncol = 1000)
for(i in 1:1000)
{
for(j in 1:1000)
{
P[i,j] <- 0.00015*exp( -0.5*( (Tij[i]/2)^2 + (Sij[j]/10)^2 ) )
}
}
filled.contour(x = Tij, y = Sij, z = P, xlab=expression(Delta~T[ij]), ylab=expression(Delta~S[ij]))
filled.contour(x = Tij, y = Sij, z = P, xlab=expression(Delta~T[ij]), ylab=expression(Delta~S[ij]), color.palette = heat.colors)
filled.contour(x = Tij, y = Sij, z = P, xlab=expression(Delta~T[ij]), ylab=expression(Delta~S[ij]), color.palette = rev(heat.colors))
filled.contour(x = Tij, y = Sij, z = P, xlab=expression(Delta~T[ij]), ylab=expression(Delta~S[ij]), color.palette = rev(heat.colors(10)))
filled.contour(x = Tij, y = Sij, z = P, xlab=expression(Delta~T[ij]), ylab=expression(Delta~S[ij]), color.palette = heat.colors)
filled.contour(x = Tij, y = Sij, z = P, xlab=expression(Delta~T[ij]), ylab=expression(Delta~S[ij]), color.palette = rainbow)
?rainbow
filled.contour(x = Tij, y = Sij, z = P, xlab=expression(Delta~T[ij]), ylab=expression(Delta~S[ij]), color.palette = topo.colors)
filled.contour(x = Tij, y = Sij, z = P, xlab=expression(Delta~T[ij]), ylab=expression(Delta~S[ij]), color.palette = terrain.colors)
filled.contour(x = Tij, y = Sij, z = P, xlab=expression(Delta~T[ij]), ylab=expression(Delta~S[ij]), color.palette = terrain.colors,
main="Probability of establishment of an Alien")
source('~/Dropbox/Invasion Risks Via Shipping Networks/R/ODE_RandomNetworks.R', echo=TRUE)
source('~/Dropbox/Invasion Risks Via Shipping Networks/R/ODE_RandomNetworks.R', echo=TRUE)
install.packages("deSolve")
install.packages("deSolve")
dnorm(-10000)
dnorm(-10000, log=T)
-rexp(1)
cubfits:::my.drawSPhiPrior
log(1:10)
exp(0.3)
exp(0:3)
exp(0:2.5)
exp(2.3)
exp(2.5)
exp(0:(2.5))
0:(2.5)
log(0.5)
phi.DrawScale <- .CF.CONF$phi.DrawScale
curr <- -100
prop <- -200
phi.curr <- 1
phi.prop <- 1.5
(prop - curr) - (phi.curr - phi.prop)
exp((prop - curr) - (phi.curr - phi.prop))
(prop - curr) - (phi.curr - phi.prop)
(exp(prop)/exp(curr))/(exp(phi.curr)/exp(phi.prop))
(prop - phi.prop) - (curr - phi.curr)
(prop - phi.curr) - (curr - phi.prop)
exp((prop - phi.curr) - (curr - phi.prop))
rmultinom(1, 3, c(0.1,0.3, 0.6))
rmultinom(1, 1, c(0.1,0.3, 0.6))
rmultinom(1, 1, c(0.1,0.3, 0.6))
rmultinom(1, 1, c(0.1,0.3, 0.6))
rmultinom(1, 1, c(0.1,0.3, 0.6))
rmultinom(1, 1, c(0.1,0.3, 0.6))
rmultinom(1, 1, c(0.1,0.3, 0.6))
rmultinom(1, 1, c(0.1,0.3, 0.6))
rmultinom(1, 1, c(0.1,0.3, 0.6))
rmultinom(1, 1, c(0.1,0.3, 0.6))
rdirichlet <- function(n, alpha){
x <- matrix(rgamma(n * length(alpha), alpha, 1), nrow = n, byrow = TRUE)
x / rowSums(x)
} # End of rdirichlet().
rdirichlet(1, c(0,1,0,0,0))
rgamma(n = 1,shape = 0, rate = 1)
?gamma
rdirichlet(1, c(1,2,1,1,1))
rdirichlet(1, c(1,2,1,1,1))
rdirichlet(1, c(1,2,1,1,1))
rdirichlet(1, c(1,2,1,1,1))
library(ribModel)
library(Rcpp)
SequenceSummary <- Module("SequenceSummary_mod")
SequenceSummary$SequenceSummary
library(ribModel)
mod <- new(SequenceSummary)
mod <- new(SequenceSummary_mod)
mod <- Module("SequenceSummary_mod")
new (mod)
mod <- Module("SequenceSummary_mod")
show(moe)
show(mod)
?Module
mod <- Module("SequenceSummary_mod", PACKAGE = "ribModel")
show(mod)
mod <- new(mod)
mod <- new(mod, "ACGTTTGCA")
mod <- Module("SequenceSummary_mod", PACKAGE = "ribModel")
show(mod)
library(ribModel)
seqsum <- SequenceSummary_mod$SequenceSummary
environment()
seqsum <- Module("SequenceSummary_mod")
library(Rcpp)
seqsum <- Module("SequenceSummary_mod")
new(seqsum)
show(seqsum)
seqsum <- Module("SequenceSummary_mod", PACKAGE = "ribModel")
show(seqsum)
library(ribModel)
SequenceSummary
seqsum <- new(SequenceSummary, "ACGTATGGGCCT")
seqsum$getAAcount( "A")
seqsum$getCodonCount("ACG")
seqsum$getCodonCount("T")
seqsum$getAAcount("T")
seqsum <- new(SequenceSummary, "atggccgttcgttga")
library(ribMoel)
library(ribModel)
seqsum <- new(SequenceSummary, "atggccgttcgttga")
seqsum$getAAcount( 'A')
seqsum$getAAcount( 'M')
seqsum$getAAcount( 'a')
seqsum$getAAcount( 'm')
seqsum$getAAcount('s')
seqsum$getAAcount('z')
seqsum$clear( )
seqsum$processSequence( "CTTCTTCTTattattatt")
seqsum$getAAcount('L')
seqsum$getAAcount('I')
seqsum$getCodonCount( "ctt")
seqsum$getCodonCount( "att")
seqsum$getCodonCount( "ATT")
seqsum$getCodonCount( "CTT")
seqsum2 <- seqsum
seqsum2$getAAcount( "I")
seqsum2$clear()
seqsum2$getAAcount( "I")
seqsum$getAAcount( "I" )
seqsum$processSequence( "CTTCTTCTTattattatt")
seqsum2 <- new(SequenceSummary, seqsum)
library(ribModel)
aminoAcids
aminoAcids
aminoAcids()
CodonToAA(codon = "ATG")
CodonToAA(codon = "ATG"
)
source('~/CodonUsageBias/RibosomeModel/RibModelFramework/ribModel/R/plotParameterObject.R', echo=TRUE)
library(ribModel)
setwd("~/CodonUsageBias/RibosomeModel/RibModelFramework/DevRscripts")
library(ribModel)
#read genome
genome <- initializeGenomeObject(fasta.file = "../ribModel/data/Skluyveri_ChrA_ChrB_andCleft.fasta")
#initialize parameter object
sphi_init <- 2;
numMixtures <- 2;
mixDef <- "allUnique";
geneAssignment <- c(rep(1,448), rep(1,513), rep(2,457))
parameter <- initializeParameterObject(genome, sphi_init, numMixtures, geneAssignment, split.serine = TRUE, mixture.definition = mixDef)
# initialize MCMC object
samples <- 100
thining <- 10
adaptiveWidth <- 100
mcmc <- initializeMCMCObject(samples, thining, adaptive.width=adaptiveWidth,
est.expression=TRUE, est.csp=TRUE, est.hyper=TRUE)
# get model object
model <- initializeModelObject("ROC")
#run mcmc on genome with parameter using model
system.time(
runMCMC(mcmc, genome, model, parameter)
)
plot(mcmc)
trace <- parameter$getTraceObject()
plot(trace, what = "MixtureProbability")
plot(trace, what = "SPhi")
plot(trace, what = "ExpectedPhi")
plot(trace, what = "Expression", geneIndex = 905)
plot(trace, what = "Mutation", mixture = 1)
plot(trace, what = "Selection", mixture = 1)
aa <- "A"
codons <- AAToCodon(aa, T)
if(length(codons) == 0) next
source('~/CodonUsageBias/RibosomeModel/RibModelFramework/ribModel/R/plotTraceObject.R', echo=TRUE)
plot(trace, what = "Mutation", mixture = 1)
plot(trace, what = "Selection", mixture = 1)
plot(model, genome, parameter, samples = samples*0.1, mixture = 1, main = "S. kluyveri Chr (A,B,Cleft) Codon Usage Plot")
